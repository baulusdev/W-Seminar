\documentclass[12pt]{article}

\usepackage{preamble}

%title, author, date
\title{Netzwerkanalyse mit Wireshark: Was passiert im Netzwerk?}
\author{Luis Herzog}
\date{April 2023}

\begin{document}

%Titlepage

\maketitle

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.1]{Bilder/Wireshark_icon.svg.png}
	\caption{Wireshark Logo \cite{wireshark-logo}}
	\label{fig:figure1}
\end{figure}

\thispagestyle{empty}
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

Es gibt viele verschiedenen Arten von Daten. Somit ebenfalls verschiedene Definitionen. 

Bevor man über die Wireshark Software sprechen kann, müssen die Basics geklärt werden:

\begin{itemize}
	\item Was sind Protokolle?
	\item Welche Protokolle gibt es?
	\item Wie funktionieren die Protokolle?
	\item welcche Protokolle (welche können ausgelesen werden?
\end{itemize}

\section{Daten}
\subsection{Metadaten}



\section{Das Programm: Wireshark}

Als ``Schweizer Taschenmesser``\cite{schweizer-taschenmesser} wird es von heise.de bezeichnet. Wireshark wird so gut wie überall in der IT-Branche benutzt. Sei es beim Finden von Netzwerkproblemen oder beim Lernen, wie ein Netzwerk funktioniert. Somit bietet das Programm eine Menge Möglichkeiten.

\subsection{Geschichte}
Wireshark wurde 1997 von Gerald Combs als `Ethereal` ins Leben gerufen. Das Programm wurde im Juli 1998 als Version 0.2.0 unter einer GPL Lizenz\cite{gnu-gpl} veröffentlich.\cite{gnu-wireshark} Somit konnten viele Menschen am Code des Programms mithelfen, um es zu verbessern. Im Jahr 2006 wurde das Projekt in `Wireshark` umbenannt. Anschließend wurde  im Jahr 2008 die Version 1.0 als erste komplette Version veröffentlicht. Sieben Jahre später wurde 2015 die Version 2.0 mit einem komplett neuen Benutzeroberfläche vorgestellt. Letztendlich wurde im Jahr 2023 die Wireshark Foundation\footnote{https://wiresharkfoundation.org/} gegründet, welche jetzt das Programm stützt. \cite{wireshark-history}

\subsection{Programm}
Wireshark ist ein ``network packet analyzer``\cite{what-is-wireshark}. Es erlaubt dem Benutzer den Netzwerkverkehr aufzunehmen und zu analysieren. Mit Wireshark kann man sozusagen in ein Netzwerkkabel `reinschauen`.

\subsection{Funktionsumfang}

Wireshark ist eine Software mit sehr vielen Funktionen und bietet fast alles rund um das Thema Netzwerkanalyse. Mit wireshark kann man den Netzwerkverkehr aufnehmen, mit hohem Detail darstellen und einfach exportieren oder speichern. Außerdem kann man exportierte Netzwerkdumps von Wireshark anderen Programmen importieren. Da Wireshark sowohl auf UNIX Platformen, als auch auf Windows verfügbar ist, geht dies sogar Plattformübergreifend. Ebenso kann man die Datenpakete anhand verschiedener Kriterien Filtern und durchsuchen. Die gerade eben genannten Funktionen kratzen aber nur an der Oberfläche. Wireshark bietet noch viel mehr Funktionen.\cite{features}

\subsection{Die Benutzeroberfläche}

Das voreingestellte Layout ist im unteren Screenshot dargestellt. In diesem Fall wird gerade die Netzwerkschnittstelle `wg-mullvad` aufgezeichnet. Im oberen Teil ist die Symbolleiste zu finden. Dort findet man Knöpfe zum starten und stoppen der Aufnahme.  Recht daneben befinden sich die Knöpfe zum Laden und Speichern von Netzwerkdumps. Weiter rechts folgen Knöpfe zum Sortieren der Paketliste. Darunter befindet sich die Liste mit den aufgenommenen Paketen. Dort kann direkt die Zeit, Quelle und Ziel des Pakets abgelesen werden. Rechts daneben kann das benutzte Netzwerkprotokoll und die Länge abgelesen werden. Ganz rechts steht weitere Information zum Paket. Unter dieser Liste befinden sich zwei Fenster. Rechts steht der rohe Inhalt des Pakets. Links hingegen steht der von Wireshark automatisch ausgelesene und geordnete Inhalt des Pakets. Hier kann jegliche Information zum Datenpaket gefunden werden. Unter diesem Fenster steht der Name der Quelle, deren Netzwerkverkehr aufgezeichnet wird. Unten ist ein Beispielscreenshot zu sehen.


\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.25]{Bilder/Screenshot_1.png}
		\label{fig:figure2}
		\caption{Beispielscreenshot aus der Wireshark Software \cite{screenshots-self}}
	\end{center}
\end{figure}



\subsection{Anwendungsbereiche}
Wie schon im oberen Teil dargestellt, bietet Wireshark sehr viele Funktionen. Somit kann Wireshark in sehr vielen Situationen Anwendung finden. Es kann beispielsweise von Netzwerk Administratoren zum Finden, Analysieren und Lösen von Netzwerkproblemen benutzt werden. Das Programm kann außerdem von Sicherheitsanalysten eines Netzwerks benutzt werden, um Sicherheitsprobleme in Netzwerken zu finden. Wiederum kann es auch von Anwendungsentwicklern benutzt werden, um die Umsetzung von Netzwerkprotokollen auszutesten. Zuletzt kann es auch benutzt werden um mehr über das Netzwerk und den Netzwerkverkehr zu lernen und diesen zu analysieren. Es gibt natürlich auch viele weitere Möglichkeiten Wireshark zu benutzen. \cite{intended-purposes}

\newpage

\section{Netzwerk}

\subsection{Aufbau}
\subsection{Protokolle}
% tcp, udp, http(s), tls/ssl,  
% tor

\subsection{Open System Interconnection Modell}


	
	\begin{wraptable}{r}{0pt}
		\centering
		\resizebox{0.6\textwidth}{!}{
			\begin{tabular}{|
					>{\columncolor[HTML]{C0C0C0}}l 
					>{\columncolor[HTML]{9B9B9B}}l l|}
				\hline
				\multicolumn{3}{|l|}{\cellcolor[HTML]{FFFFFF}OSI-Modell}                                                                                                             \\ \hline
				\multicolumn{1}{|l|}{\cellcolor[HTML]{C0C0C0}}                               & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}7} & \cellcolor[HTML]{34FF34}Application  \\ \cline{2-3} 
				\multicolumn{1}{|l|}{\cellcolor[HTML]{C0C0C0}}                               & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}6} & \cellcolor[HTML]{34FF34}Presentation \\ \cline{2-3} 
				\multicolumn{1}{|l|}{\cellcolor[HTML]{C0C0C0}}                               & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}5} & \cellcolor[HTML]{34FF34}Session      \\ \cline{2-3} 
				\multicolumn{1}{|l|}{\multirow{-4}{*}{\cellcolor[HTML]{C0C0C0}Host Layers}}  & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}4} & \cellcolor[HTML]{67FD9A}Transport    \\ \hline
				\multicolumn{1}{|l|}{\cellcolor[HTML]{C0C0C0}}                               & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}3} & \cellcolor[HTML]{F8FF00}Network      \\ \cline{2-3} 
				\multicolumn{1}{|l|}{\cellcolor[HTML]{C0C0C0}}                               & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}2} & \cellcolor[HTML]{F56B00}Data Link    \\ \cline{2-3} 
				\multicolumn{1}{|l|}{\multirow{-3}{*}{\cellcolor[HTML]{C0C0C0}Media Layers}} & \multicolumn{1}{l|}{\cellcolor[HTML]{9B9B9B}1} & \cellcolor[HTML]{FE0000}Physical     \\ \hline
			\end{tabular}%
		}
			\caption{OSI-Modell \cite{osi-table}}
		\label{fig:figure3}
	\end{wraptable}

	


	Das Open System Interconnect\footnote{dt: Offenes System für Kommunikationsverbindungen} Modell, auch OSI-Modell genannt, beschreibt die Voraussetzungen, die für eine Kommunikation innerhalb eines Netzwerks nötig sind. Dieses wurde 1983 von durch die `Internationale Organisation für Normung`, kurz `ISO` standardisiert. Dies ist notwendig, damit sich alle Komponenten im Netwerk, auch wenn diese von verschiedenen Herstellern produziert wurden, reibungslos miteinander funktionieren. Wenn ein Paket beispielsweise von einem Computer im Netwerk losgeschickt wird, muss es mehrere Stationen durchlaufen. Das Paket verlässt den Rechner über die Netzwerkkarte und wird durch ein Übertragungsmedium über weitere Netzwerkkomponenten, wie Hubs oder Router bis zur Netzwerkkarte des Zielrechners geleitet. Dort wird dieses dann Interpretiert, um korrekt dargestellt zu werden. All diese Schritte werden durch ein Protokoll festgehalten und durch das OSI-Modell spezifiziert, damit jede Station auf diesem Weg weiß, wohin das Paket möchte, woher es kommt und welche Eigenschaften es hat. So wird ein Standart geschaffen, mit dem alle Computersysteme miteinander kommunizieren können.
	
	Da diese  Datenkommunikation relativ komplex ist, wurde das Modell in sieben Schichten eingeteilt. Die oberen vier Schichten gehören zu den Anwendungsorientierten Schichten\footnote{engl: Host layer}. Die unteren drei Schichten werden Transport Schichten\footnote{dt: Media layer} genannt. Jede Schicht behandelt eine Anforderung, die für eine funktionierende Kommunikation erfüllt werden muss. Ein zu übertragenes Paket durchläuft vor der Versendung die Schichten 7 - 2, wobei dem Paket bei jeder Schicht Protokoll-Informationen hinzugefügt werden, die dann im Protokoll des Datenpaketes auffindbar sind. Die erste und letzte Schicht wandelt das Paket in technisch übertragbare Daten um und schickt dieses über das Übertragsmedium weg. Das Übertragsmedium kann hierbei ein Kabel sein, oder aus einer Antenne bestehen. Auf der Empfängerseite wird dieser Prozess rückwärts durchgeführt. Hierbei wird die jeweilige Protokoll-Information nach der Interpretierung durch die jeweilige Schicht entfernt, bis zum Inhalt des Paketes.
	
	Im folgenden werden die einzelnen Schichten  einzeln beleuchtet, um einen besseren Einblick zu gewähren.

\subsubsection{Anwendungsschicht}
	Die Anwendungsschicht\footnote{engl: application layer} stellt die Daten dar, mit welchen der Nutzer interagiert. Softwareanwendungen, wie Web-Browser und E-Mail clients stützen sich auf die siebte Schicht, um dem Nutzer aussagekräftige Daten zu präsentieren. 
	
	Hierzu gehören Protokolle, wie HTTP\footnote{Hyper Text Transfer Protocol}, welches benutzt wird, um Websites welche in HTML\footnote{Hyper Text Markup Language} geschrieben sind zu präsentieren, oder SMTP\footnote{Simple Mail Transfer Protocol}, welches benutzt wird um E-Mails zu präsentieren.

\subsubsection{Präsentationsschicht}
	Die Präsentationsschicht\footnote{engl: presentation layer} ist in erster Linie dafür verantwortlich, die Daten so aufzubereiten, dass diese in der Anwendungsschicht verwendet werden können. Ein wichtiger Teil dabei ist die Verschlüsselung. Die Präsentationsschicht muss, wenn die Geräte durch eine verschlüsselte Verbindung kommunizieren, auf Senderseite eine Verschlüsselung hinzufügen und diese auf der Empfängerseite korrekt dekodieren. 
	
	Ebenso ist die Präsentationsschicht für die Komprimierung der Daten verantwortlich. Dadurch kann die Geschwindigkeit und Effizienz der Kommunikation erhöht und die benötigte Bandbreite minimiert werden.

\subsubsection{Sitzungsschicht}
	Anschließend folgt die Sitzungsschicht\footnote{engl: session layer}. Diese ist für das Öffnen und Schließen der Kommunikation der beiden Geräte zuständig. Hier wird die Kommunikation in Sitzungen eingeteilt. Eine Sitzung reicht von der Öffnung bis zur Schließung der Verbindung. Somit wird sicher gestellt, dass die Sitzung lange genug geöffnet bleibt, um alle Daten zu übertragen. Wenn alle Daten erfolgreich übertragen wurden, leitet die Sitzungsschicht die umgehende Schließung der Sitzung ein, um Ressourcen zu sparen. 
	
	Eine weitere sehr wichtige Aufgabe der Sitzungsschicht ist die Sicherung der Datenverbindung durch synchronisierte Checkpoints. Wenn beispielsweise bei der Übertragung einer 450 Megabyte großen Datei bei 234 Megabyte die Verbindung unterbrochen wird, kann nach einer Neuverbindung die Übertragung bei 230 Megabyte wieder aufgenommen werden, da es einen Checkpoint der Datei bei 230 Megabyte gibt.

\subsubsection{Transportschicht}
	In der Transportschicht\footnote{engl: transport layer} werden die Datenpakete vor dem Versenden in Segmente zerlegt. Im Empfangsgerät werden die diese Segmente durch die Transportschicht wieder korrekt zusammengesetzt, sodass diese von der Sitzungsschicht benutzt werden können. 
	
	Die Transportebene ist ebenfalls für die Fluss- und Fehlersteuerung zuständig. Hierbei wird die Übertragungsgeschwindigkeit so festgelegt, dass ein ggf. langsamer Empfänger nicht durch die ggf. schnelle Geschwindigkeit des Senders überfordert wird. Beim Empfänger wird durch die Fehlersteuerung ein vollständiger Empfang aller Daten sichergestellt. Wenn die empfangenen Daten nicht vollständig sind, werden diese durch dieses System erneut angefordert, um die Vollständigkeit der Daten zu garantieren. 
	
	Hierzu gehören die Protokolle TCP\footnote{Transmission Control Protocol} und UDP\footnote{User Datagram Protocol}

\paragraph{Exkurs: UDP/TCP}
   
   
\subsubsection{Netzwerkschicht}
	Darauf folgt die Netzwerkschicht\footnote{engl: network layer}. Diese gewährt das Kommunizieren zwischen Geräten in verschiedenen, miteinander verbundenen Netzwerken. Beim Versenden, werden die Segmente der Transportschicht erneut in kleinere Datenpakete aufgeteilt und mit weiteren Informationen versehen. Diese Informationen sind für die, auf dem Weg gelegenen, Knoten gedacht, um diesen das Ziel des Pakets aufzuweisen. Es wird der beste physikalisch mögliche Weg ausgesucht, um die Daten sicher an ihr Ziel zu bringen. Dieser Prozess wird Routing\footnote{Quelle!} genannt.
	Wenn sich beide Geräte im selben Netzwerk befinden, wird diese Ebene übersprungen. 
	
	Zu den Protokollen für diese Schicht gehören das IP\footnote{Internet Protocol}, das ICMP\footnote{Internet Control Message Protocol}, das IGMP\footnote{Internet Group Message Protocol} und die IPsec\footnote{??} Suite. Ein Beispielgerät wäre ein Router.
	
\subsubsection{Sicherungsschicht}
	Die Sicherungsschicht\footnote{engl: Data Link Layer} stellt die vorletzte Schicht dar. Diese ist der Netzwerkschicht sehr ähnlich. Der wesentliche Unterschied ist, dass die Sicherungsschicht für die Kommunikation von zwei Geräten innerhalb eines Netzwerks zuständig ist. Die Sicherungsschicht ist ebenfalls für die Fluss- und Fehlerkontrolle in der netzinternen Kommunikation zuständig. 
	
	Beispielgeräte für diese Ebene wären Bridges und Switches.

\subsubsection{Bitübertragungsschicht}
	Die unterste Schicht wird durch die Bitübertragungsschicht\footnote{engl: physical layer} dargestellt. Hier sind die Daten als Bitstrom vorhanden, eine Zeichenkette bestehend aus einen und nullen. Hier muss sich auf mehrere Konventionen geeinigt werden. Zu Beginn müssen die Gegebenheiten des Übertragungsmediums festgelegt werden. Dies betrifft die Wahl des Materials und die Funktion der einzelnen Leitungen. Ein Kabel kann beispielsweise aus Kupfer oder Glasfaser bestehen und zwei innere Leitungen haben: eine Datenleitung und eine Steuerleitung. Bei der Übertragung über Funk wird beispielsweise durch Luft übertragen. Es muss ebenfalls die Übertragungsrichtung und Geschwindigkeit festgelegt werden. Ein Kabel kann in eine Richtung\footnote{simplex}, abwechselnd in beide Richtungen\footnote{halb-duplex} oder in beide Richtungen gleichzeitig\footnote{duplex} übertragen.





\section{Analyse}
In der Analyse soll viel benutzte Software getestet werden. Ich habe mich für Web-Browser entschieden, da diese am meisten benutzt werden\footnote{QUELLE!}. Zu beginn soll die Software getestet werden. Hierfür habe ich einen simplen Test erstellt.
\subsection{Beispiel}
In diesem Kapitel soll eine Beispielkommunikation vereinfacht dargestellt werden. Es wird ein lokaler Webserver erstellt und anschließend kontaktiert. Dieser Transfer wird dann durch Wireshark aufgezeichnet.

\subsubsection{Der Webserver}
Code: 

\begin{lstlisting}
	from flask import Flask #importieren von den benoetigten Bibliotheken
	import os
	from datetime import datetime
	
	hostName = "localhost" #setzen des Hostnamen
	serverPort = 8080 #setzen des Ports (Erklaerung unter dem Code)
	app = Flask(__name__) #der Flask Server wird instanziert
	@app.route('/') #wenn zum index geroutet wird...
	def index():
	return '<p>willkommen in der http webserver demo</p>'  #...soll diese response zurueckgeschickt werden
	@app.route('/time') #wenn zu /time geroutet wird...
	def time():
	now = datetime.now()
	current_time = now.strftime("%H:%M:%S") #erstellen der response
	return f'Jetzige Zeit: {current_time}' #...soll diese response zurueckgeschickt werden
	
	if __name__ == '__main__':
	app.run(host=hostName, port=serverPort) #starten des Servers
\end{lstlisting}

Mit der `flask`Bibliothek können Webserver in Python leicht umgesetzt werden. Sie erlaubt es Webserver zu erstellen, die auf requests hören und mit dem angefragten Inhalt antworten\cite{flask}

\paragraph{Weitere Erklärung zum Code:}
``Ports sind ein Merkmal der Protokolle TCP und UDP``\cite{ports19}. Diese werden benutzt, um den Datenverkehr zu ordnen. Da auf einem Server oft mehrere Programme aktiv sind, die gleichzeitig über das Netzwerk kommunizieren müssen diese eingeteilt werden, sodass die Pakete nicht durcheinander kommen. Jedes Programm legt seinen Port fest, bzw. bekommt vom Betriebssystem einen Port zugewiesen. Dieser kann zwischen 0 und 65535 liegen.\cite{ports}

Anschließend wird Wireshark geöffnet und das richtige Interface, welches aufgenommen werden soll, ausgewählt. In `diesem Fall ist es das `Loopback:io` interface. \textbf{(siehe: Anlagen, Das Wireshark interface, auswählen des Loopback Geräts)}
\subsubsection{Das `loopback device`}

Das Loopback interace ist eine ``Pseudo-Netzwerkschnittstelle zum gefahrenlosen Testen``\cite{loopback-munich}. Der Nertzwerktraffic wird in diesem Fall, da der Server auf `localhost`live ist. Das loopback interface agiert als virtuelle Netzwerkkarte und ist nicht wirklich als Hardware vorhanden. Da ich diesen Test auf einem Linux Betriebssystem durchführe ist diese Funktion durch Wireshark unterstützt.\cite{loopback-wireshark}

\subsubsection{Ergebnis}

Nun muss der Server kontaktiert werden. Dies kann man mit einem Web-Browser machen. Mit Firefox habe ich dann `http://localhost:8080` kontaktiert. In Wireshark sind direkt mehrere neue Einträge zu erkennen. \textbf{(siehe: Anlagen, der Datentransfer wurde aufgezeichnet)}

Im nächsten Schritt wird das erste request, mit dem `HTTP` Protocoll angesehen. \textbf{(siehe: Anlagen, Analyse des `GET` requests)}. Unten rechts ist der Inhalt des Pakets zu erkennen. Darin sind einige Daten zum Browser enthalten und zum Inhalt, welcher angefragt wird. Diese Daten werden später in der Analyse weiter durchleuchtet.

Der Server antwortet mit diesem angeforderten Inhalt \textbf{(siehe: Anlagen, Analyse der response)}. Der Inhalt ist, der oben im Code festgelegte Satz, ``Willkommen in der http Webserver demo``

\subsection{Browser}
\subsubsection{Mozilla Firefox}
\subsubsection{Microsoft Edge}
 \subsubsection{Mullvad Browser}
\subsubsection{Opera Browser}




 \section{Fazit}

% end of text

\newpage
 \listoffigures
 \listoftables
\newpage
\bibliographystyle{plain}
\bibliography{gg}

\newpage

\centering
\vspace*{200pt}
\Huge{\section{Anlagen}}
\newpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Bilder/Anlagen_1}
	\caption{Das Wireshark interface, auswählen des Loopback Geräts \cite{screenshots-self}}
	\label{fig:figure30}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Bilder/Anlagen_2}
	\caption{Das Wireshark interface, warten auf Datentransfer \cite{screenshots-self}}
	\label{fig:figure31}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Bilder/Anlagen_3}
	\caption{Das Wireshark interface, der Datentransfer wurde aufgezeichnet \cite{screenshots-self}}
	\label{fig:figure32}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Bilder/Anlagen_4}
	\caption{Das Wireshark interface, Analyse des `GET` requests \cite{screenshots-self}}
	\label{fig:figure33}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Bilder/Anlagen_5}
	\caption{Das Wireshark interface, Analyse der response \cite{screenshots-self}}
	\label{fig:figure34}
\end{figure}


\end{document}

